# Code Quality Analysis and Improvement Suggestions

This document tracks identified areas for improvement across the project codebase.

---

## 1. Core Logic (c_logic.cpp / c_logic.h)
- [ ] **Coordinate System Consistency**: The code mix uses (x,y) and 1-32 square numbers. Standardizing on one internally (likely 0-31 bit indices) and only converting at the edges (UI/IO) would reduce `coorstonumber` call overhead.
- [ ] **Macro vs Const**: Many `#define` constants (like `CB_MAN`, `CB_KING`) should be converted to `constexpr` or `enum class` for better type safety.
- [ ] **makemovelist Performance**: Uses `CBmove captures[MAXMOVES]` which is a fairly large struct array on the stack. Could be optimized if move generation becomes a bottleneck.
- [ ] **Error Handling**: Functions like `FENtobitboard_pos` return 0/1 for success. Switching to a more descriptive error enum or `std::optional` would be more idiomatic.

---

## 2. AI Engine (AIWorker.cpp / AIWorker.h)
- [ ] **Transposition Table Size**: Currently uses `std::unordered_map`. While functional, a fixed-size pre-allocated array (with replacement scheme) would be much faster and avoid dynamic memory allocation during search.
- [ ] **Search Parallelization**: The AI search is single-threaded. Implementing Lazy SMP or Young Brothers Wait Concept would significantly improve search depth on multi-core CPUs.
- [ ] **Move Ordering**: Currently uses history heuristic and killer moves. Adding See (Static Exchange Evaluation) or refining the capture scoring would further improve pruning.
- [ ] **Evaluation Function**: The PSTs are 8x8. Since checkers only uses 32 squares, these can be compressed to 1D arrays to save cache and simplify indexing.
- [ ] **Zobrist Table Initialization**: `initZobristKeys` is called every time an AIWorker is created. These keys should be static and initialized once to ensure consistency.

---

## 3. Game Management (GameManager.cpp / GameManager.h)
- [ ] **State Encapsulation**: Player types (`m_whitePlayer`, `m_blackPlayer`) are currently separate from the `CBoptions` struct. Consolidating all game settings into one place would simplify serialization.
- [ ] **Move History**: Currently uses `QList<QString>` of FENs. For long games, storing a list of `CBmove` structs and only regenerating FENs on demand would be more memory efficient and facilitate "Undo" functionality.
- [ ] **Hardcoded Constants**: Values like `timeLimit = 1.0` in `requestAiMove` should be pulled from `m_options.time_per_move`.
- [ ] **Game Loop Robustness**: The `detectDraws` and `goForward` functions are stubs. Implementing the 50-move rule and position repetition detection is necessary for a complete engine.

---

## 4. UI Rendering (BoardWidget.cpp / BoardWidget.h)
- [ ] **Pixmap Caching**: `loadPiecePixmaps` scales bitmaps every time it's called. While infrequent, pre-scaling all piece sets and storing them in a static cache would make theme switching instantaneous.
- [ ] **Paint Event Efficiency**: `paintEvent` redraws every square and piece every time. Using a `QPixmap` as a back-buffer for the static board and only drawing pieces/highlights on top would be more efficient.
- [ ] **Coordinate Math**: `boardToScreen` and `screenToBoard` are called repeatedly. Pre-calculating these mapping tables on resize would slightly improve responsiveness.
- [ ] **Responsive Design**: `m_squareSize` is fixed at 60. Implementing a `resizeEvent` handler to scale the board to fill the available window space would improve UX on different monitors.

---

## 5. Data and Storage (DBManager.cpp / egdb_driver)
- [ ] **Cache Efficiency**: `get_db_data_block` uses a linear search for cache hits (`MAXCACHEDBLOCKS` is currently small). For larger cache sizes, using a hash map for block lookups would be much faster.
- [ ] **Memory Mapping**: The Linux version uses standard `fread`. On 64-bit systems, memory-mapping (`mmap`) the EGDB files would significantly improve performance and let the OS handle caching.
- [ ] **Thread-Safety redundancy**: Both `DBManager` (Qt mutex) and `egdb_driver` (Internal mutex) have locking. Consolidating this or ensuring the internal driver is strictly thread-safe without caller overhead would be cleaner.
- [ ] **Error Propagation**: EGDB errors (like `EGDB_FILE_READ_ERROR`) are logged but often return `EGDB_UNKNOWN`. Propagating detailed error states up to the UI would aid in debugging missing database files.

---

## 6. Application Lifecycle and Threading (main.cpp / Logger.cpp)
- [ ] **Logger Singleton Cleanup**: The `Logger` instance is never explicitly deleted. Adding a cleanup function or using a smart pointer would ensure the destructor runs and writes the "Log Ended" message.
- [ ] **Thread-Safe Initialization**: `Logger::instance()` and `DBManager::instance()` are not inherently thread-safe for the very first call. Using `std::call_once` or `Q_GLOBAL_STATIC` would be more robust.
- [ ] **Build System Source Management**: `build_checkerboard.sh` manually lists source files. Using a dynamic glob or switching to CMake/Meson would make adding new files easier and less error-prone.
- [ ] **Asset Portability**: The code assumes bitmaps are in `./bmp/`. Bundling these into the Qt Resource file (`.qrc`) was started but ensuring the entire app can run as a single standalone binary without external folders would be ideal.





